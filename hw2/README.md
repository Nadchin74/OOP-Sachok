# Доповідь: Принцип підстановки Лісков (LSP)

## Вступ
**Принцип підстановки Лісков (LSP)** стверджує: *об'єкти базового класу повинні мати можливість бути заміненими об'єктами його підкласів без порушення правильності роботи програми.*

Якщо підклас змушує код "ламатися" або поводитися непередбачувано при заміні батьківського класу — це порушення LSP. Нижче наведено 3 класичні приклади порушення цього принципу.

---

## Приклад 1: Птах та Страус
*Проблема реалізації поведінки (біологічне наслідування).*

###  Проблема
У нас є базовий клас `Bird` (Птах) з методом `Fly()` (Літати). Ми створюємо клас `Ostrich` (Страус), який успадковує `Bird`. Оскільки страуси не літають, у методі `Fly()` ми змушені викидати виняток.

```csharp
class Bird {
    public virtual void Fly() { /* Летить */ }
}

class Ostrich : Bird {
    public override void Fly() {
        throw new Exception("Страуси не літають!");
    }
}
```
###  Чому це порушує LSP?
Клієнтський код, який працює зі списком `List<Bird>`, очікує, що **всі** птахи можуть літати. Якщо передати туди страуса, програма впаде. Підклас не може коректно замінити базовий клас.

###  Як виправити (Рішення)
Розділити можливості на різні інтерфейси.

1. Виділити інтерфейс `IFlyable`.
2. Клас `Bird` залишається базовим для спільних рис (вага, пір'я).
3. `Eagle` реалізує `Bird` та `IFlyable`.
4. `Ostrich` реалізує тільки `Bird`.

---

## Приклад 2: Банківський рахунок
*Проблема посилення передумов.*

###  Проблема
Є базовий клас `BankAccount`, який дозволяє знімати гроші, якщо баланс позитивний. Підклас `FixedTermDeposit` (Депозит) забороняє знімати гроші, доки не скінчиться термін вкладу.

```csharp
class BankAccount {
    public virtual void Withdraw(decimal amount) {
        if (Balance >= amount) { /* ОК, знімаємо */ }
    }
}

class FixedTermDeposit : BankAccount {
    public override void Withdraw(decimal amount) {
        if (!IsTermFinished) 
            throw new Exception("Не можна знімати гроші достроково!");
        
        base.Withdraw(amount);
    }
}
```
###  Чому це порушує LSP?
Це порушення правила **"не посилювати передумови"**.

* **Батько каже:** "Можна зняти, якщо є гроші".
* **Дитина каже:** "Можна зняти, якщо є гроші **І** минув час".

Клієнтський код, який розраховує на контракт базового класу, отримає помилку там, де її не очікує.

###  Як виправити (Рішення)
Розділити ієрархію або інтерфейси:

* Використовувати `IWithdrawable` тільки для поточних рахунків.
* Депозитний рахунок не повинен мати методу `Withdraw`, який обіцяє миттєву видачу коштів, або повинен повертати статус операції замість гарантії виконання.

---

## Приклад 3: Тільки для читання (ReadOnly)
*Проблема зміни контракту незмінності.*

###  Проблема
Є базовий клас `ProjectFile` з методами `Load()` та `Save()`. Створюється підклас `ReadOnlyFile`, який у методі `Save()` викидає помилку.

```csharp
class ProjectFile {
    public virtual void Save(string text) { /* Запис на диск */ }
}

class ReadOnlyFile : ProjectFile {
    public override void Save(string text) {
        throw new InvalidOperationException("Файл тільки для читання!");
    }
}
```
###  Чому це порушує LSP?
Клієнт, який отримує `ProjectFile`, впевнений, що може зберегти дані (це обіцянка базового класу). Підклас порушує цю обіцянку. Це змушує писати перевірки типу `if (file is not ReadOnlyFile)`, що є поганим стилем (**"Code Smell"**).

###  Як виправити (Рішення)
Інвертувати ієрархію:

1. Базовий клас `ReadableFile` (має тільки `Load`).
2. Клас `WritableFile` успадковується від `ReadableFile` і додає метод `Save`.
3. `ReadOnlyFile` стає просто екземпляром `ReadableFile`.

---

## Висновок
Порушення LSP часто виникає, коли наслідування використовується для повторного використання коду, а не для розширення поведінки.

**Головне правило:** Підклас не повинен вимагати від клієнта знати, з ким саме він працює. Якщо метод перекрито лише для того, щоб викинути виняток `NotSupportedException` — це вірна ознака порушення LSP.