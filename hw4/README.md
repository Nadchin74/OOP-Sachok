# Доповідь: Factory Method vs Abstract Factory — Муки вибору

## Вступ
У об’єктно-орієнтованому проектуванні породжувальні патерни (Creational Patterns) відіграють ключову роль у відділенні логіки створення об'єктів від бізнес-логіки програми. Найчастіше розробники стикаються з вибором між **Factory Method** (Фабричний метод) та **Abstract Factory** (Абстрактна фабрика). Хоча обидва патерни вирішують схожу проблему, вони мають суттєві архітектурні відмінності.

---

## 1. Різниця між патернами

Головна відмінність полягає у **масштабі** та **способі реалізації**.

### Factory Method (Фабричний метод)
Цей патерн зосереджений на створенні **одного** продукту. Він визначає інтерфейс для створення об'єкта, але дозволяє підкласам вирішувати, який саме клас інстанціювати.
* **Механізм:** Використовує **спадкування**. Базовий клас містить абстрактний метод створення, а підкласи реалізують його, повертаючи конкретні продукти.
* **Суть:** *"Я не знаю, який саме продукт мені знадобиться, але я знаю, що він повинен мати певний інтерфейс. Нехай спадкоємці вирішують деталі".*

### Abstract Factory (Абстрактна фабрика)
Цей патерн призначений для створення **сімейств** пов'язаних або залежних об'єктів без вказівки їхніх конкретних класів.
* **Механізм:** Використовує **композицію**. Клієнтський код володіє посиланням на об'єкт фабрики (інтерфейс), яка вміє створювати кілька різних продуктів (наприклад: кнопка, вікно, чекбокс), що належать до однієї "теми".
* **Суть:** *"Мені потрібен набір речей, які гарантовано пасують одна одній (стілець + стіл + диван в одному стилі). Дайте мені фабрику, яка видає весь цей комплект".*

---

## 2. Сценарії використання

### Коли обирати Factory Method?
1. **Невизначеність типів:** Ви заздалегідь не знаєте, з якими типами об'єктів доведеться працювати вашому коду.
2. **Розширюваність бібліотек:** Ви пишете фреймворк або бібліотеку і хочете дати користувачам можливість розширювати її внутрішні компоненти (наприклад, створити власну кнопку замість стандартної).
3. **Економія ресурсів:** Коли потрібно контролювати створення об'єктів, наприклад, повертати вже існуючий екземпляр замість створення нового (Pool об'єктів).

### Коли обирати Abstract Factory?
1. **Сімейства продуктів:** Ваша система повинна працювати з різними сімействами продуктів (наприклад, темна/світла тема UI), і ви хочете переконатися, що клієнт не отримає "мікс" з несумісних об'єктів.
2. **Приховування реалізації:** Ви хочете надати бібліотеку об'єктів, розкриваючи тільки їхні інтерфейси, а не реалізацію.
3. **Кросплатформність:** Коли програма має працювати на різних ОС (Windows, Linux, macOS), і для кожної ОС потрібен свій набір віджетів, які виглядають рідними для системи.

---

## 3. Переваги та недоліки

### Factory Method

**Переваги:**
* **Декаплінґ (Decoupling):** Позбавляє від жорсткої прив'язки до конкретних класів продуктів.
* **SRP (Single Responsibility Principle):** Код створення продукту переміщується в одне місце.
* **OCP (Open/Closed Principle):** Можна додавати нові типи продуктів, не змінюючи існуючий клієнтський код.

**Недоліки:**
* **Ускладнення ієрархії:** Може призвести до створення великої кількості паралельних ієрархій класів (для кожного нового продукту потрібен свій підклас творця).

### Abstract Factory

**Переваги:**
* **Гарантія сумісності:** Ви можете бути впевнені, що продукти, отримані від однієї фабрики, сумісні між собою.
* **Ізоляція конкретних класів:** Клієнт маніпулює об'єктами тільки через їх абстрактні інтерфейси.
* **Дотримання принципів SOLID:** Працюють принципи єдиної відповідальності та відкритості/закритості.

**Недоліки:**
* **Надмірна складність:** Впровадження великої кількості інтерфейсів та класів робить код складнішим для розуміння.
* **Важкість розширення сімейства:** Якщо в сімейство потрібно додати новий *тип* продукту (наприклад, окрім "Кнопки" та "Вікна" додати "Слайдер"), доведеться змінювати інтерфейс базової фабрики та **всіх** її конкретних реалізацій.

---

## Висновок: Як зробити вибір?

Починайте простіше. Часто проектування починається з використання **Factory Method**, оскільки він є менш складним і достатньо гнучким для більшості задач.

Якщо ж з часом ви помічаєте, що вашій програмі потрібно створювати безліч різнорідних об'єктів, які мають логічний зв'язок між собою (групуються в сімейства), тоді варто виконати рефакторинг у бік **Abstract Factory**.

* **Один тип продукту** → Factory Method.
* **Сімейство продуктів** → Abstract Factory.