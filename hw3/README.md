# Звіт з лабораторної роботи: Принципи ISP та DIP

## 1. Interface Segregation Principle (ISP) — Принцип розділення інтерфейсу
Принцип ISP стверджує, що краще мати багато спеціалізованих інтерфейсів, ніж один універсальний. Клієнти не повинні залежати від методів, які вони не використовують.

### Приклад порушення ISP
Уявімо інтерфейс для системи Smart Home, де один інтерфейс описує всі можливі дії пристроїв:

```csharp
public interface ISmartDevice {
    void Burn();      // Для лампочки
    void PlayMusic(); // Для колонки
    void HeatFood();  // Для мікрохвильовки
}

// Порушення: Лампочка змушена реалізовувати методи музики та підігріву
public class LightBulb : ISmartDevice {
    public void Burn() => Console.WriteLine("Світло увімкнено");
    public void PlayMusic() => throw new NotImplementedException(); 
    public void HeatFood() => throw new NotImplementedException();
}
```
## Вирішення проблеми (Refactoring)

Розділяємо інтерфейс на "вузькі" сегменти, щоб кожен пристрій залежав лише від потрібного функціоналу:

```csharp
public interface ILight { void Burn(); }
public interface ISpeaker { void PlayMusic(); }
public interface IOven { void HeatFood(); }

public class BetterLightBulb : ILight {
    public void Burn() => Console.WriteLine("Світло увімкнено");
}
```
## 2. Dependency Inversion Principle (DIP) — Принцип інверсії залежностей

DIP каже, що високорівневі модулі не повинні залежати від низькорівневих. Обидва мають залежати від абстракцій.

### Переваги застосування DIP через Dependency Injection (DI):
* **Гнучкість (Flexibility):** Ми можемо замінити реалізацію сервісу (наприклад, змінити відправку повідомлень з Email на SMS або Telegram), не змінюючи код бізнес-логіки.
* **Слабкий зв'язок (Loose Coupling):** Класи взаємодіють через інтерфейси, що зменшує ризик того, що зміна в одному модулі зламає інший.
* **Контроль життєвого циклу:** За допомогою DI-контейнерів можна легко керувати тим, як створюються об'єкти (Singleton, Scoped, Transient).

## 3. Синергія ISP, DIP та тестування
"Вузькі" інтерфейси (ISP) є фундаментом для якісного впровадження залежностей (DI) та ефективного тестування:

* **Легке макування (Mocking):** Коли інтерфейс "вузький", вам потрібно реалізувати лише 1-2 методи у Mock-об'єкті для тесту. Якщо інтерфейс "товстий", тест захаращується непотрібним кодом.
* **Точність тестування:** Ви точно знаєте, яку частину системи ви тестуєте. Залежність лише від потрібного функціоналу робить тести ізольованими.
* **Покращення DI-контейнерів:** Реєстрація дрібних інтерфейсів дозволяє гнучкіше налаштовувати систему. Один клас може реалізовувати 3 вузьких інтерфейси, але DI видасть кожному споживачеві лише ту "роль", яка йому потрібна.

### Висновок
Дотримання ISP дозволяє уникнути "мертвого" коду в реалізаціях, а DIP звільняє систему від жорстких прив'язок до конкретних класів. Разом вони роблять архітектуру гнучкою, а процес тестування — швидким та зрозумілим.